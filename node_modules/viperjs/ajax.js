var _Ajax__settings = {
        type: 'GET',
        dataType: 'json',
        success: Function__nop,
        error: Function__nop,
        complete: Function__nop,
        timeout: 0,
    };

/* exported Ajax__settings */
function Ajax__settings(options) {
    Object__extend(_Ajax__settings, options);
}

/* exported Ajax__ajax */
function Ajax__ajax(url, options) {
    var xhr = new XMLHttpRequest(),
        query = null,
        contentType = options.contentType,
        timer,
        hasTimeout = false;

    options = Object__extend({}, options, true);
    Object__defaults(options, _Ajax__settings);
    options.type = options.type.toUpperCase();

    // 设置默认
    if (!contentType && options.type == 'POST') {
        contentType = 'form';
    }

    if (!contentType) {
        url = String__param(options.data, url);
    }

    xhr.open(options.type, url, true);

    if (options.timeout > 0) {
        timer = setTimeout(function() {
            hasTimeout = true;
            xhr.abort();
        }, options.timeout);
    }

    Dom__on(xhr, 'readystatechange', function() {
        var data,
            type;

        if (xhr.readyState != 4) {
            return;
        }

        clearTimeout(timer);

        if (hasTimeout) {
            type = 'timeout';
        } else if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            data = xhr.responseText;

            if (options.dataType == 'json') {
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    type = 'parsererror';
                }
            }
        } else {
            type = 'error';
        }

        if (type) {
            options.error(type, xhr);
        } else {
            type = 'success';
            options.success(data, xhr);
        }

        options.complete(type, xhr);
    });

    if (contentType == 'form') {
        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        query = String__param(options.data);
    }

    if (contentType == 'json') {
        xhr.setRequestHeader('Content-type', 'application/json');
        query = JSON.stringify(options.data);
    }

    if (contentType == 'form-data') {
        query = new FormData();
        Object__each(options.data, function(key, val) {
            query .append(key, val);
        });
    }

    xhr.send(query);

    return xhr;
}

var _Ajax__jsonpCallbackGlobalKey = 'jsonp' + Date.now(),
    _Ajax__jsonpCallbackObject,
    _Ajax__jsonpCallbackId = 0;

/* exported Ajax__jsonp */
function Ajax__jsonp(url, options) {
    var $script = document.createElement('script'),
        $head = document.head,
        callbackKey = 'cb' + (++_Ajax__jsonpCallbackId),
        timer,
        hasTimeout = false;

    if (!_Ajax__jsonpCallbackObject) {
        _Ajax__jsonpCallbackObject = window[_Ajax__jsonpCallbackGlobalKey] = {};
    }

    options = Object__extend({}, options, true);
    Object__defaults(options, _Ajax__settings);

    if (options.timeout > 0) {
        timer = setTimeout(function() {
            hasTimeout = true;
            options.error();
            options.complete('timeout');
        }, options.timeout);
    }

    function clear() {
        $head.removeChild($script);
        delete _Ajax__jsonpCallbackObject[callbackKey];
    }

    function callback(data) {
        if (!hasTimeout) {
            clearTimeout(timer);
            options.success(data);
            options.complete('success');
        }

        clear();
    }

    _Ajax__jsonpCallbackObject[callbackKey] = callback;

    if (options.callback) {
        window[options.callback] = callback;
    }

    url = url.replace(/=\?/, '=' + _Ajax__jsonpCallbackGlobalKey + '.' + callbackKey);
    url = String__param(options.data, url);

    Dom__on($script, 'error', function() {
        if (!hasTimeout) {
            clearTimeout(timer);
            options.error();
            options.complete('error');
        }

        clear();
    });

    $script.src = url;
    $head.appendChild($script);
}

/* exported Ajax__cache */
/*
 *  url: ajax url
 *  options: ajax options
 *      dataType: assumed as 'json'
 *      key: localStorage key
 *      cacheTimeout: timeout to use localStorage instead of ajax, not ajax timeout, can be 0.
 *      update: function(data) {}, called when cacheTimeout and success is called with cache, then data arrived.
 *      filter: if (filter) { data = filter(data); }    // 注意filter不要破坏hash
 */
function Ajax__cache(url, options) {
    options = Object__extend({}, options, true);
    options.dataType = 'json';

    Object__defaults(options, {
        key: url,
        cacheTimeout: 1000,
        success: Function__nop,
        error: Function__nop,
        complete: Function__nop,
        update: Function__nop,
        data: {},
    });

    var success = options.success,
        error = options.error,
        complete = options.complete,
        cache = LocalStorage__get(options.key),
        timer,
        done = false;

    if (cache) {
        cache = JSON.parse(cache);
        options.data.hash = cache.hash;
    }

    options.success = function(data, xhr) {
        if (cache && data && data.hash && data.hash == cache.hash) {
            data = cache;
        } else {
            if (options.filter) {
                data = options.filter(data);
            }

            LocalStorage__set(options.key, JSON.stringify(data));
        }

        (done ? options.update : success)(data, xhr);
    };

    options.error = function(xhr, type, exception) {
        if (!done) {
            if (cache) {
                done = true;
                success(cache);
                complete('cache');
            } else {
                error(xhr, type, exception);
            }
        }
    };

    options.complete = function(type, xhr) {
        clearTimeout(timer);

        if (!done) {
            complete(type, xhr);
        }
    };

    if (cache) {
        timer = setTimeout(function() {
            done = true;
            success(cache);
            complete('cache');
        }, options.cacheTimeout);
    }

    return Ajax__ajax(url, options);
}

/* exported Ajax__stream */
/*
 *  url: ajax url
 *  options: ajax options
 *      stream[]:
 *          url: stream url
 *          data: stream data
 *          isArray: result is JSON array splitted by '\r'
 *          callback: function(data) {}
 *      streamComplete: complete callback
 *      streamKey: default 'list'
 */
function Ajax__stream(url, options) {
    var xhr,
        pos = 0,
        checkedPos = 0,
        processed = 0;

    options = Object__extend({}, options, true);

    Object__defaults(options, {
        stream: [],
        streamKey: 'list',
        streamComplete: Function__nop,
        data: {},
    });

    options.dataType = undefined;
    options.data[options.streamKey] = options.stream.map(function(streamOptions) {
        return String__param(streamOptions.data, streamOptions.url);
    });

    xhr = Ajax__ajax(url, options);

    function process(text) {
        var length = text.length,
            newPos,
            textArray,
            i,
            data,
            json,
            streamOptions;

        if (length == checkedPos) {
            return;
        }

        for (;;) {
            newPos = text.indexOf('\r', checkedPos);

            if (!~newPos) {
                checkedPos = length;
                break;
            } else if (text[newPos + 1] != '\n') {
                checkedPos = newPos + 1;

                if (checkedPos == length) {
                    checkedPos--;
                    break;
                }

                continue;
            }

            streamOptions = options.stream[processed++];

            if (streamOptions && streamOptions.callback) {
                textArray = text.slice(pos, newPos).split('\r');

                data = [];
                for (i = 0; i < textArray.length; i++) {
                    try {
                        json = JSON.parse(textArray[i]);
                    } catch (e) {
                        json = undefined;
                    }

                    data.push(json);
                }

                setTimeout(streamOptions.callback.bind(undefined, streamOptions.isArray ? data : data[0]), 0);    // force chunked
            }

            pos = checkedPos = newPos + 2;
        }
    }

    Dom__on(xhr, 'progress', function() {
        var data = this.responseText || '';

        process(data);
    });

    Dom__on(xhr, 'readystatechange', function() {
        var data = this.responseText || '';

        if (xhr.readyState != 4) {
            return;
        }

        process(data);

        setTimeout(function() {
            options.streamComplete(processed);
        }, 0);
    });

    return xhr;
}

/* exported Ajax__streamCache */
/*
 *  url: ajax url
 *  options: ajax options
 *      stream[]:
 *          url: stream url
 *          data: stream data
 *          isArray: result is JSON array splitted by '\r'
 *          callback: function array, function(data, isUpdate) {if (data === undefined) error(); if (isUpdate) update();}
 *          key: localStorage key
 *          filter: if (filter) { data = filter(data); }    // 注意filter不要破坏hash
 *      streamComplete: complete callback
 *      cacheTimeout: timeout to use localStorage instead of ajax, not ajax timeout, can be 0.
 *      streamKey: default 'list'
 */
function Ajax__streamCache(url, options) {
    options = Object__extend({}, options, true);

    Object__defaults(options, {
        stream: [],
        cacheTimeout: 1000,
        streamComplete: Function__nop,
    });

    var processed = 0,
        origStreamComplete = options.streamComplete,
        timer;

    Array__each(options.stream, function(streamOptions) {
        var isArray = streamOptions.isArray,
            key = streamOptions.key || streamOptions.url,
            filter = streamOptions.filter,
            callback = streamOptions.callback || Function__nop,
            cache = LocalStorage__get(key),
            useCache = false,
            useRemote = false;

        if (cache) {
            cache = JSON.parse(cache);
        }

        if (cache) {
            streamOptions.data = streamOptions.data || {};

            if (isArray) {
                if (cache instanceof Array) {
                    streamOptions.data.hash = cache.map(function(item) {
                        return item && item.hash;
                    }).join(',');
                }
            } else if (cache.hash) {
                streamOptions.data.hash = cache.hash;
            }
        }

        streamOptions.callback = function(data) {
            var needUpdate = false,
                i;

            if (data == undefined) {
                if (cache && !useCache && !useRemote) {
                    processed++;
                    callback(cache);
                    useCache = true;
                }
            } else {
                if (filter) {
                    data = filter(data);
                }

                if (isArray) {
                    if (data instanceof Array) {
                        if (cache instanceof Array) {
                            for (i = 0; i < data.length; i++) {
                                if (cache[i] && data[i] && data[i].hash && data[i].hash == cache[i].hash) {
                                    data[i] = cache[i];
                                } else {
                                    needUpdate = true;
                                }
                            }
                        } else {
                            needUpdate = true;
                        }
                    }
                } else if (cache && data && data.hash && data.hash == cache.hash) {
                    data = cache;
                } else {
                    needUpdate = true;
                }

                if (!useCache) {
                    processed++;
                    callback(data);
                    useRemote = true;
                } else if (needUpdate) {
                    callback(data, true);
                }

                if (needUpdate) {
                    LocalStorage__set(key, JSON.stringify(data));
                }
            }
        };
    });

    function complete() {
        var streamOptions,
            i;

        for (i = processed; i < options.stream.length; i++) {
            streamOptions = options.stream[i];

            if (streamOptions && streamOptions.callback) {
                setTimeout(streamOptions.callback, 0);
            }
        }
    }

    timer = setTimeout(function() {
        complete();

        setTimeout(function() {
            if (processed == options.stream.length) {
                origStreamComplete(processed);
                origStreamComplete = Function__nop;
            }
        }, 0);
    }, options.cacheTimeout);

    options.streamComplete = function() {
        clearTimeout(timer);
        complete();

        setTimeout(function() {
            origStreamComplete(processed);
        }, 0);
    };

    return Ajax__stream(url, options);
}

/*
 * used in common/diff/js/loader.js
 */
/* exported Ajax__tinyGet */
function Ajax__tinyGet(url, success) {
    var xhr = new XMLHttpRequest();

    xhr.open('GET', url, true);

    xhr.onreadystatechange = function() {
        var status = xhr.status;

        if (xhr.readyState == 4 && ((status >= 200 && status < 300) || status == 304)) {
            success(xhr.responseText);
        }
    };

    xhr.send();
}
