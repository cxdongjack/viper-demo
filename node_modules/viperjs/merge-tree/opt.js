include([
    '../../lib/all.js',
]);

/* exported mergeTree__optList */
/* exported mergeTree__listKey */
/* exported _mergeTree__listKey */

var mergeTree__listKey = 'key';

function _mergeTree__listKey(node) {
    return node.nodeType == 1 && node.getAttribute(mergeTree__listKey);
}

function mergeTree__optList(a, b) {
    var dict = mergeTree__optListPrepare(a, b);
    if (!dict) {
        return;
    }
    var i, childrenA, childrenB;
    // 特意使用childNodes，动态数组
    // 减少移动次数，比如1,2,3,4 -> 2,3,4，在现有算法里只用一次replace
    childrenA = a.childNodes;
    childrenB = Array__slice(b.childNodes);
    for(i = 0;i < childrenB.length;i++) {
        mergeTree__optListResort(childrenA, childrenB, dict, i);
    }
}

function mergeTree__optListPrepare($old, $new) {
    // 列表优化：准备一个包含所有列表项的字典
    var isList = Array__find($new.childNodes, _mergeTree__listKey);
    if (!isList) {
        return;
    }
    var dict = {};
    // 新节点使用占位节点
    Array__each($new.childNodes, function(node) {
        var uuid = _mergeTree__listKey(node);
        if (uuid) {
            dict[uuid] = document.createComment('key=' + uuid);
        }
    });
    // 优先使用旧节点
    Array__each($old.childNodes, function(node) {
        var uuid = _mergeTree__listKey(node);
        if (uuid) {
            dict[uuid] = node;
        }
    });
    return dict;
}

function mergeTree__optListResort(childrenA, childrenB, dict, i) {
    // 如果A已经越界，重新排序结束
    if (!childrenA[i]) {
        return;
    }
    // 获取B节点的uuid
    var uuid = _mergeTree__listKey(childrenB[i]);
    if (!uuid) {
        return;
    }
    // 如果节点相等，说明新旧两边顺序一样
    if (childrenA[i] == dict[uuid]) {
        return;
    }
    // 如果节点不相等，说明新旧两边顺序一样, 进行调整
    Dom__replace(childrenA[i], dict[uuid]);
}
